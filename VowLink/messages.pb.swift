// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: VowLink/messages.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Proto_Hello {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_Link {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tbs: Proto_Link.TBS {
    get {return _storage._tbs ?? Proto_Link.TBS()}
    set {_uniqueStorage()._tbs = newValue}
  }
  /// Returns true if `tbs` has been explicitly set.
  var hasTbs: Bool {return _storage._tbs != nil}
  /// Clears the value of `tbs`. Subsequent reads from it will return its default value.
  mutating func clearTbs() {_uniqueStorage()._tbs = nil}

  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TBS {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var trusteePubKey: Data = SwiftProtobuf.Internal.emptyData

    var expiration: Double = 0

    /// NOTE: This MUST be filled either by sender/recipient before
    /// generating/verifying the signature below.
    var channelID: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelPubKey: Data {
    get {return _storage._channelPubKey}
    set {_uniqueStorage()._channelPubKey = newValue}
  }

  var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  var channelRoot: Proto_ChannelMessage {
    get {return _storage._channelRoot ?? Proto_ChannelMessage()}
    set {_uniqueStorage()._channelRoot = newValue}
  }
  /// Returns true if `channelRoot` has been explicitly set.
  var hasChannelRoot: Bool {return _storage._channelRoot != nil}
  /// Clears the value of `channelRoot`. Subsequent reads from it will return its default value.
  mutating func clearChannelRoot() {_uniqueStorage()._channelRoot = nil}

  var chain: [Proto_Link] {
    get {return _storage._chain}
    set {_uniqueStorage()._chain = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_EncryptedInvite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var box: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QR Code
struct Proto_InviteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerID: String = String()

  var trusteePubKey: Data = SwiftProtobuf.Internal.emptyData

  var boxPubKey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ChannelMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  /// NOTE: can be empty only in the root message
  var parents: [Data] = []

  /// height = max(p.height for p in parents)
  var height: UInt64 = 0

  /// Encryption nonce for Sodium
  var nonce: Data = SwiftProtobuf.Internal.emptyData

  /// NOTE: encryption key = HASH(channelPubKey, 'vowlink-symmetric')
  var encryptedContent: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// First message on any channel
  struct Root {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Text {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Body {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var body: OneOf_Body? {
      get {return _storage._body}
      set {_uniqueStorage()._body = newValue}
    }

    var root: Proto_ChannelMessage.Root {
      get {
        if case .root(let v)? = _storage._body {return v}
        return Proto_ChannelMessage.Root()
      }
      set {_uniqueStorage()._body = .root(newValue)}
    }

    var text: Proto_ChannelMessage.Text {
      get {
        if case .text(let v)? = _storage._body {return v}
        return Proto_ChannelMessage.Text()
      }
      set {_uniqueStorage()._body = .text(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Body: Equatable {
      case root(Proto_ChannelMessage.Root)
      case text(Proto_ChannelMessage.Text)

    #if !swift(>=4.1)
      static func ==(lhs: Proto_ChannelMessage.Body.OneOf_Body, rhs: Proto_ChannelMessage.Body.OneOf_Body) -> Bool {
        switch (lhs, rhs) {
        case (.root(let l), .root(let r)): return l == r
        case (.text(let l), .text(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Content {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Link chain that leads from the channel's public key to the signer of
    /// this message
    var chain: [Proto_Link] {
      get {return _storage._chain}
      set {_uniqueStorage()._chain = newValue}
    }

    /// Floating point unix time
    var timestamp: Double {
      get {return _storage._timestamp}
      set {_uniqueStorage()._timestamp = newValue}
    }

    /// body of the message
    var body: Proto_ChannelMessage.Body {
      get {return _storage._body ?? Proto_ChannelMessage.Body()}
      set {_uniqueStorage()._body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    var hasBody: Bool {return _storage._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    mutating func clearBody() {_uniqueStorage()._body = nil}

    var signature: Data {
      get {return _storage._signature}
      set {_uniqueStorage()._signature = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TBS {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var chain: [Proto_Link] {
        get {return _storage._chain}
        set {_uniqueStorage()._chain = newValue}
      }

      var timestamp: Double {
        get {return _storage._timestamp}
        set {_uniqueStorage()._timestamp = newValue}
      }

      var body: Proto_ChannelMessage.Body {
        get {return _storage._body ?? Proto_ChannelMessage.Body()}
        set {_uniqueStorage()._body = newValue}
      }
      /// Returns true if `body` has been explicitly set.
      var hasBody: Bool {return _storage._body != nil}
      /// Clears the value of `body`. Subsequent reads from it will return its default value.
      mutating func clearBody() {_uniqueStorage()._body = nil}

      /// NOTE: Despite these fields being outside of content they have to be
      /// included here to prevent replay attacks
      var parents: [Data] {
        get {return _storage._parents}
        set {_uniqueStorage()._parents = newValue}
      }

      var height: UInt64 {
        get {return _storage._height}
        set {_uniqueStorage()._height = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct Proto_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  var cursor: Proto_Query.OneOf_Cursor? = nil

  var height: UInt64 {
    get {
      if case .height(let v)? = cursor {return v}
      return 0
    }
    set {cursor = .height(newValue)}
  }

  var hash: Data {
    get {
      if case .hash(let v)? = cursor {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {cursor = .hash(newValue)}
  }

  var isBackward: Bool = false

  var limit: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Cursor: Equatable {
    case height(UInt64)
    case hash(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Query.OneOf_Cursor, rhs: Proto_Query.OneOf_Cursor) -> Bool {
      switch (lhs, rhs) {
      case (.height(let l), .height(let r)): return l == r
      case (.hash(let l), .hash(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Proto_QueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  var messages: [Proto_ChannelMessage] = []

  var forwardHash: Data = SwiftProtobuf.Internal.emptyData

  var backwardHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_Subscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var invite: Proto_EncryptedInvite {
    get {
      if case .invite(let v)? = _storage._content {return v}
      return Proto_EncryptedInvite()
    }
    set {_uniqueStorage()._content = .invite(newValue)}
  }

  var message: Proto_ChannelMessage {
    get {
      if case .message(let v)? = _storage._content {return v}
      return Proto_ChannelMessage()
    }
    set {_uniqueStorage()._content = .message(newValue)}
  }

  var error: Proto_Error {
    get {
      if case .error(let v)? = _storage._content {return v}
      return Proto_Error()
    }
    set {_uniqueStorage()._content = .error(newValue)}
  }

  var subscribe: Proto_Subscribe {
    get {
      if case .subscribe(let v)? = _storage._content {return v}
      return Proto_Subscribe()
    }
    set {_uniqueStorage()._content = .subscribe(newValue)}
  }

  var query: Proto_Query {
    get {
      if case .query(let v)? = _storage._content {return v}
      return Proto_Query()
    }
    set {_uniqueStorage()._content = .query(newValue)}
  }

  var queryResponse: Proto_QueryResponse {
    get {
      if case .queryResponse(let v)? = _storage._content {return v}
      return Proto_QueryResponse()
    }
    set {_uniqueStorage()._content = .queryResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case invite(Proto_EncryptedInvite)
    case message(Proto_ChannelMessage)
    case error(Proto_Error)
    case subscribe(Proto_Subscribe)
    case query(Proto_Query)
    case queryResponse(Proto_QueryResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Packet.OneOf_Content, rhs: Proto_Packet.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.invite(let l), .invite(let r)): return l == r
      case (.message(let l), .message(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.subscribe(let l), .subscribe(let r)): return l == r
      case (.query(let l), .query(let r)): return l == r
      case (.queryResponse(let l), .queryResponse(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var secretKey: Data = SwiftProtobuf.Internal.emptyData

  var channelChains: [Proto_Identity.ChannelChain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ChannelChain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var channelID: Data = SwiftProtobuf.Internal.emptyData

    var links: [Proto_Link] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Proto_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var root: Proto_ChannelMessage {
    get {return _storage._root ?? Proto_ChannelMessage()}
    set {_uniqueStorage()._root = newValue}
  }
  /// Returns true if `root` has been explicitly set.
  var hasRoot: Bool {return _storage._root != nil}
  /// Clears the value of `root`. Subsequent reads from it will return its default value.
  mutating func clearRoot() {_uniqueStorage()._root = nil}

  /// XXX(indutny): this is a temporary solution. Use Core Data like a real iOS
  /// developer.
  var messages: [Proto_ChannelMessage] {
    get {return _storage._messages}
    set {_uniqueStorage()._messages = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Proto_ChannelList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channels: [Proto_Channel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Hello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hello"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Hello, rhs: Proto_Hello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tbs"),
    2: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _tbs: Proto_Link.TBS? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tbs = source._tbs
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tbs)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tbs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Link, rhs: Proto_Link) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tbs != rhs_storage._tbs {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Link.TBS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_Link.protoMessageName + ".TBS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trustee_pub_key"),
    2: .same(proto: "expiration"),
    3: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.trusteePubKey)
      case 2: try decoder.decodeSingularDoubleField(value: &self.expiration)
      case 3: try decoder.decodeSingularBytesField(value: &self.channelID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trusteePubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.trusteePubKey, fieldNumber: 1)
    }
    if self.expiration != 0 {
      try visitor.visitSingularDoubleField(value: self.expiration, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Link.TBS, rhs: Proto_Link.TBS) -> Bool {
    if lhs.trusteePubKey != rhs.trusteePubKey {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Invite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_pub_key"),
    2: .standard(proto: "channel_name"),
    3: .standard(proto: "channel_root"),
    4: .same(proto: "chain"),
  ]

  fileprivate class _StorageClass {
    var _channelPubKey: Data = SwiftProtobuf.Internal.emptyData
    var _channelName: String = String()
    var _channelRoot: Proto_ChannelMessage? = nil
    var _chain: [Proto_Link] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channelPubKey = source._channelPubKey
      _channelName = source._channelName
      _channelRoot = source._channelRoot
      _chain = source._chain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._channelPubKey)
        case 2: try decoder.decodeSingularStringField(value: &_storage._channelName)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._channelRoot)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._chain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._channelPubKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._channelPubKey, fieldNumber: 1)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 2)
      }
      if let v = _storage._channelRoot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._chain.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chain, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Invite, rhs: Proto_Invite) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelPubKey != rhs_storage._channelPubKey {return false}
        if _storage._channelName != rhs_storage._channelName {return false}
        if _storage._channelRoot != rhs_storage._channelRoot {return false}
        if _storage._chain != rhs_storage._chain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EncryptedInvite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedInvite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "box"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.box)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.box.isEmpty {
      try visitor.visitSingularBytesField(value: self.box, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EncryptedInvite, rhs: Proto_EncryptedInvite) -> Bool {
    if lhs.box != rhs.box {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InviteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InviteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "trustee_pub_key"),
    3: .standard(proto: "box_pub_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.peerID)
      case 2: try decoder.decodeSingularBytesField(value: &self.trusteePubKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.boxPubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peerID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerID, fieldNumber: 1)
    }
    if !self.trusteePubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.trusteePubKey, fieldNumber: 2)
    }
    if !self.boxPubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.boxPubKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InviteRequest, rhs: Proto_InviteRequest) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.trusteePubKey != rhs.trusteePubKey {return false}
    if lhs.boxPubKey != rhs.boxPubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "parents"),
    3: .same(proto: "height"),
    4: .same(proto: "nonce"),
    5: .standard(proto: "encrypted_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.parents)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 4: try decoder.decodeSingularBytesField(value: &self.nonce)
      case 5: try decoder.decodeSingularBytesField(value: &self.encryptedContent)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    if !self.parents.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.parents, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 4)
    }
    if !self.encryptedContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedContent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelMessage, rhs: Proto_ChannelMessage) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.parents != rhs.parents {return false}
    if lhs.height != rhs.height {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.encryptedContent != rhs.encryptedContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelMessage.Root: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChannelMessage.protoMessageName + ".Root"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelMessage.Root, rhs: Proto_ChannelMessage.Root) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelMessage.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChannelMessage.protoMessageName + ".Text"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.text)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelMessage.Text, rhs: Proto_ChannelMessage.Text) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelMessage.Body: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChannelMessage.protoMessageName + ".Body"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
    2: .same(proto: "text"),
  ]

  fileprivate class _StorageClass {
    var _body: Proto_ChannelMessage.Body.OneOf_Body?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_ChannelMessage.Root?
          if let current = _storage._body {
            try decoder.handleConflictingOneOf()
            if case .root(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._body = .root(v)}
        case 2:
          var v: Proto_ChannelMessage.Text?
          if let current = _storage._body {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._body = .text(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._body {
      case .root(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelMessage.Body, rhs: Proto_ChannelMessage.Body) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelMessage.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChannelMessage.protoMessageName + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "body"),
    4: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _chain: [Proto_Link] = []
    var _timestamp: Double = 0
    var _body: Proto_ChannelMessage.Body? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chain = source._chain
      _timestamp = source._timestamp
      _body = source._body
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._chain)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._timestamp)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._body)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._chain.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chain, fieldNumber: 1)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timestamp, fieldNumber: 2)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelMessage.Content, rhs: Proto_ChannelMessage.Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chain != rhs_storage._chain {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelMessage.Content.TBS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChannelMessage.Content.protoMessageName + ".TBS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "body"),
    4: .same(proto: "parents"),
    5: .same(proto: "height"),
  ]

  fileprivate class _StorageClass {
    var _chain: [Proto_Link] = []
    var _timestamp: Double = 0
    var _body: Proto_ChannelMessage.Body? = nil
    var _parents: [Data] = []
    var _height: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _chain = source._chain
      _timestamp = source._timestamp
      _body = source._body
      _parents = source._parents
      _height = source._height
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._chain)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._timestamp)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._body)
        case 4: try decoder.decodeRepeatedBytesField(value: &_storage._parents)
        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._chain.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chain, fieldNumber: 1)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularDoubleField(value: _storage._timestamp, fieldNumber: 2)
      }
      if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._parents.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._parents, fieldNumber: 4)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelMessage.Content.TBS, rhs: Proto_ChannelMessage.Content.TBS) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chain != rhs_storage._chain {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._parents != rhs_storage._parents {return false}
        if _storage._height != rhs_storage._height {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Query"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "height"),
    3: .same(proto: "hash"),
    4: .standard(proto: "is_backward"),
    5: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2:
        if self.cursor != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.cursor = .height(v)}
      case 3:
        if self.cursor != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.cursor = .hash(v)}
      case 4: try decoder.decodeSingularBoolField(value: &self.isBackward)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    switch self.cursor {
    case .height(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    case .hash(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case nil: break
    }
    if self.isBackward != false {
      try visitor.visitSingularBoolField(value: self.isBackward, fieldNumber: 4)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Query, rhs: Proto_Query) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.isBackward != rhs.isBackward {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_QueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "messages"),
    3: .standard(proto: "forward_hash"),
    4: .standard(proto: "backward_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 3: try decoder.decodeSingularBytesField(value: &self.forwardHash)
      case 4: try decoder.decodeSingularBytesField(value: &self.backwardHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    if !self.forwardHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.forwardHash, fieldNumber: 3)
    }
    if !self.backwardHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.backwardHash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_QueryResponse, rhs: Proto_QueryResponse) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.forwardHash != rhs.forwardHash {return false}
    if lhs.backwardHash != rhs.backwardHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Error, rhs: Proto_Error) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Subscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subscribe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Subscribe, rhs: Proto_Subscribe) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Packet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invite"),
    2: .same(proto: "message"),
    3: .same(proto: "error"),
    4: .same(proto: "subscribe"),
    5: .same(proto: "query"),
    6: .standard(proto: "query_response"),
  ]

  fileprivate class _StorageClass {
    var _content: Proto_Packet.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Proto_EncryptedInvite?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .invite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .invite(v)}
        case 2:
          var v: Proto_ChannelMessage?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .message(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .message(v)}
        case 3:
          var v: Proto_Error?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .error(v)}
        case 4:
          var v: Proto_Subscribe?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .subscribe(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .subscribe(v)}
        case 5:
          var v: Proto_Query?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .query(v)}
        case 6:
          var v: Proto_QueryResponse?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .queryResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .queryResponse(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._content {
      case .invite(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .message(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .subscribe(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .query(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .queryResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Packet, rhs: Proto_Packet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "secret_key"),
    3: .standard(proto: "channel_chains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.secretKey)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.channelChains)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.secretKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.secretKey, fieldNumber: 2)
    }
    if !self.channelChains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelChains, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Identity, rhs: Proto_Identity) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.secretKey != rhs.secretKey {return false}
    if lhs.channelChains != rhs.channelChains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Identity.ChannelChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_Identity.protoMessageName + ".ChannelChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.channelID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.links)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularBytesField(value: self.channelID, fieldNumber: 1)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Identity.ChannelChain, rhs: Proto_Identity.ChannelChain) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "name"),
    3: .same(proto: "root"),
    4: .same(proto: "messages"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Data = SwiftProtobuf.Internal.emptyData
    var _name: String = String()
    var _root: Proto_ChannelMessage? = nil
    var _messages: [Proto_ChannelMessage] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _name = source._name
      _root = source._root
      _messages = source._messages
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._root)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._messages)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._root {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Channel, rhs: Proto_Channel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._root != rhs_storage._root {return false}
        if _storage._messages != rhs_storage._messages {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChannelList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.channels)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChannelList, rhs: Proto_ChannelList) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
